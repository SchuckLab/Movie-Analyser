// Macro to Classify movies into predefined groups from multi cell montages by clicking.

// Get directory of the cell montage (has to be generated by the MakeMontage.ijm first) + catch
args = getArgument();
if (lengthOf(args) != 0) {
	if (File.isDirectory(args)) dir = args;
} else {
	dir = getDirectory("Select assembly folder of cells to be classified ...");
}
if (File.getName(File.getParent(dir)) != "assemblies") exit("The assembly folder must be located in the default location (assemblies).");
if (!File.exists(dir+"sorting.txt")) exit("No sorting file containing the original file names of the crops could be detected.");
dirspool = File.getParent(File.getParent(dir));
print(dirspool);

// Process arguments contained in the assemblysettings.cfg
settings = readSettings(dir+"assemblySettings.cfg");
rows = getSetting(settings, "rows", 3);
columns = getSetting(settings, "columns", 5);
print("Assemblies generated of points"+settings[1]+", will be displayed for classification.");

// See whether flags have been defined already
if (!File.exists(dirspool+File.separator+"flagdefinitions.txt")) exit("Please define the flags you want to assign in this project first.");
availableflags = File.openAsString(dirspool+File.separator+"flagdefinitions.txt");
availableflags = split(availableflags,"\n");
for (i=0; i<availableflags.length;i++) availableflags[i] = replace(availableflags[i], "\t", "  "); 

// Create default flag - click mapping
clickmask = newArray(16, 17, 18, 4, 5, 6); // actual bitmasks returned from the getCurserLoc
clickname = newArray("left click", "shift left click", "ctrl left click", "right click", "shift right click", "ctrl right click"); // lcick description displayed to the user
if (availableflags.length >= 6) clickflag = Array.trim(availableflags, 6); // default flag assigned by each click (rows of flagdefinitions.txt)
else {
	clickflag = availableflags;
	while(clickflag.length < 6) {
		clickflag = Array.concat(clickflag, newArray("unassigned"));
	}
}

// Get previous flag mapping and overwrite the default
if (File.exists(dirspool+File.separator+"flagmapping.cfg")) {
	oldmapping = File.openAsString(dirspool+File.separator+"flagmapping.cfg");
	oldmapping = split(oldmapping,"\n");
	for (i=0;i<6;i++) {
		line = arrayIndexOf(oldmapping, clickmask[i]);
		if (line == -1) clickflag[i] = "unassigned";
		else {
			line = split(oldmapping[line], "\t");
			flag = line[1];
			flag = arrayIndexOf(availableflags, flag);
			clickflag[i] = availableflags[flag];
		}
	}
	if (oldmapping.length == 7) {
		line = split(oldmapping[6], "\t");
		if (line.length < 2) allflag = "unassigned";
		else {
			flag = line[1];
			flag = arrayIndexOf(availableflags, flag);
			allflag = availableflags[flag];
		}
	}
	else allflag = "unassigned";
}
else allflag = "unassigned";

// Display user dialog to assign flags to clicks
availableflags = Array.concat(availableflags, "unassigned");
flagfile = dirspool+File.separator+"classification.csv";
Dialog.create("Map flags to clicks ... ");
name = call("ij.Prefs.get", "MovieAnalyser.Name", "user");
Dialog.addString("Name of this classification set:", name+"-##");
if (File.exists(flagfile)) {
	oldclass = File.openAsString(flagfile);
	oldclass = split(oldclass, "\n");
	classifications = split(oldclass[0], "\t");
	basis = Array.slice(classifications, 2, classifications.length);
	basis = Array.concat(basis, "none");
	Dialog.addChoice("Old classification to use as basis:", basis, "none");
}
Dialog.addMessage("Please select which flag you want to assign by which click:");
for (i=0;i<6;i++) {
	Dialog.addChoice(clickname[i], availableflags, clickflag[i]); // Display 6 dropdown menus, with lines from flagdefinitions as options and clickflag as default
}
Dialog.addChoice("Optional flag to assign to all cells in this run:", availableflags, allflag);
Dialog.addMessage("alt right click    undo last click assignment");
Dialog.addCheckbox("Save as default assignment", false);
Dialog.show();
classname = Dialog.getString();
if (File.exists(flagfile)) basis = Dialog.getChoice();
else basis = "none";
for (i=0;i<6;i++) {
	clickflag[i] = Dialog.getChoice();
}
allflag = Dialog.getChoice();
savemapping = Dialog.getCheckbox();

// Trim flags to assigned values and single characters, save as default if ticked
while (arrayIndexOf(clickflag, "unassigned") != -1) {
	rm = arrayIndexOf(clickflag, "unassigned");
	clickflag = arrayRemoveItem(clickflag, rm);
	clickmask = arrayRemoveItem(clickmask, rm);
	clickname = arrayRemoveItem(clickname, rm);
}
for (i=0;i<clickflag.length;i++) {
	print(clickname[i]+"    "+clickflag[i]+"\n");
	clickflag[i] = substring(clickflag[i],0,1);
}
print("alt right click    undo last click assignment");
if (allflag == "unassigned") allflag = "";
else {
	print(allflag+" will be assigned to all cells.");
	allflag = substring(allflag,0,1);
}
if (savemapping) {
	f = dirspool+File.separator+"flagmapping.cfg";
	if (File.exists(f)) File.delete(f);
	f = File.open(f);
	for (i=0;i<clickflag.length;i++) {
		print(f, clickmask[i]+"\t"+clickflag[i]);
	}
	print(f, "all\t"+allflag);
	File.close(f);
}

// write to log if it exists
if (File.exists(dirspool+File.separator+"log.txt")) {
	entry = getDateYMD();
	folder = File.getName(dir);
	flags = arrayCollapse(clickflag, ", ");
	entry = entry+"\t"+name+"\tstarted classification\tof '"+folder+"' with flags ("+flags+") to set "+classname;
	File.append(entry, dirspool+File.separator+"log.txt");
}

// Read in sorting of files in the assemblies and initialize flag array with "c"s
sorting = File.openAsString(dir+"sorting.txt");
sorting = split(sorting, "\n");
for (i=0;i<sorting.length;i++) {
	x = split(sorting[i], "\t/");
	x = arrayCollapse(x, "\t");
	sorting[i] = x;
}
n=sorting.length;
assignedflags = newArray(n);
for(i=0;i<assignedflags.length;i++) assignedflags[i] = "c"+allflag;

// Read in filenames of the assemblies
files = getFileList(dir);
for (i=0; i<files.length; i++) {
	assembly = endsWith(files[i], ".tif");
	if (!assembly) {
		files = arrayRemoveItem(files, i);
		i--;
	}
}
print(files.length+" assemblies will be shown.\nClose the open assembly to continue with the next.");

// Read assigned flags if it already exists and merge with the newly assigned ones
if (basis != "none") {
	basis = arrayIndexOf(classifications, basis);
	for (i=0;i<sorting.length;i++) { // loop through all classified files
		fileID = arrayIndexOf(oldclass, sorting[i]);
		if (fileID != -1) { // file was already classified
			old = split(oldclass[fileID], "\t");
			old = old[basis];
			if (old == " ") old = "";
			joined = old+assignedflags[i];
			joined = removeDuplicateCharacters(joined);
			assignedflags[i] = joined;
		}
	}
}

// Open all assemblies and track user clicks
setFont("sans-serif", 12, "antialiased");
for (i=0; i<files.length; i++) {
	open(dir+files[i]);
	print("Assembly "+(i+1)+" loaded.");
	if (getVersion>="1.37r")
	setOption("DisablePopupMenu", true);
	getDimensions(w,h,ch,sl,fr);
	if (i==0) tilewidth = w/columns;
	u = updateOverlay(rows, columns, tilewidth, i, assignedflags);
	for (c=1;c<=ch;c++) {
		Stack.setChannel(c);
		resetMinAndMax();
	}
	x2=-1; y2=-1; z2=-1; flags2 = 0; column=-1; row=-1;
	released = 1; assign = false;
	while(isOpen(files[i]) == true) {
		getCursorLoc(x, y, z, flags);
		if (flags!=flags2) released = 1; // keep flag updated all the time, so releasing the mouse and clicking on the same position again counts
		if ((x!=x2 || y!=y2 || z!=z2 || released) && (flags&4!=0 || flags&16!=0)) { // if user clicks or drags to a new position
			column2 = floor(x/tilewidth);
			row2 = floor(y/tilewidth);
			if (released || column!=column2 || row!=row2) { // and if click is either different from before or on a new tile
				if (flags == 12 && assign != false) { // alt right click -> undo last flag
					if (indexOf(assignedflags[tile], assign) != -1) {
						assignedflags[tile] = replace(assignedflags[tile], assign, ""); // remove flag
						print("\\Update:"+assign+" removed from cell "+tile);
					}
					else {
						assignedflags[tile] = assignedflags[tile]+assign; // add flag
						print("\\Update:cell "+tile+" flagged with "+assign);
					}
				}
				else if (arrayIndexOf(clickmask, flags) != -1) {
					for (c=0;c<clickmask.length;c++) {
						if (flags == clickmask[c]) {
							assign = clickflag[c];
						}
					}
					column = floor(x/tilewidth);
					row = floor(y/tilewidth);
					tile = pad((row*columns)+column+(i*rows*columns));
					if (parseInt(tile) < assignedflags.length) { // Necessary in case the user drags outside the window
						if (indexOf(assignedflags[tile], assign) != -1) {
							assignedflags[tile] = replace(assignedflags[tile], assign, ""); // remove flag
							print("\\Update:"+assign+" removed from cell "+tile);
						}
						else {
							assignedflags[tile] = assignedflags[tile]+assign; // add flag
							print("\\Update:cell "+tile+" flagged with "+assign);
						}
					}
				}
				x2=x; y2=y; z2=z; flags2=flags; released = 0;
				u = updateOverlay(rows, columns, tilewidth, i, assignedflags);
				wait(30);
			}
		}
	}
}

// (Remove duplicate assignments) and sort flags
for (i=0; i<assignedflags.length;i++) {
	x = assignedflags[i];
	x = removeDuplicateCharacters(x);
	assignedflags[i] = x;
}

// Write assignedflags and sorting to file just incase something goes wrong now
rnd = random;
rndcopy = rnd;
rnd = File.open(dir+File.separator+rnd);
for (i=0;i<assignedflags.length;i++) {
	print(rnd, sorting[i]+"\t"+assignedflags[i]);
}
File.close(rnd);

// Old merging before user management and parallel saving of classifications was added:
// // Generate classificaiton array containing filenames and flags
// classification = newArray();
// for (i=0;i<sorting.length;i++) { // loop through all classified files
// 	classification = Array.concat(classification, sorting[i]+"\t"+assignedflags[i]);
// }
// newclassification = classification;
// 
// // Read assigned flags if it already exists and merge with the newly assigned ones
// flagfile = dirspool+File.separator+"classification.csv";
// if (File.exists(flagfile)) {
// 	classification = File.openAsString(flagfile);
// 	classification = split(classification, "\n");
// 	for (i=0;i<sorting.length;i++) { // loop through all newly classified files
// 		fileID = arrayIndexOf(classification, sorting[i]);
// 		if (fileID != -1) { // file was already classified -> replace with newclassification
// 			classification[fileID] = newclassification[i];
// 		}
// 		else {
// 			classification = Array.concat(classification, newclassification[i]);
// 		}
// 	}
// }

// Merging of old and new classifications
// read in old classification or initialize column headings
flagfile = dirspool+File.separator+"classification.csv";
if (File.exists(flagfile)) {
	lines = File.openAsString(flagfile);
	lines = split(lines, "\n");
}
else lines = newArray("Point\tCell\t"+classname);

// define which column to write to
title = split(lines[0], "\t");
ncol = title.length;
col = arrayIndexOf(title, classname);
if (col == -1) {
	col = ncol;
	lines[0] = lines[0]+"\t"+classname;
}
// print("column index of saved classification = "+col);

// Go through old lines and add or update classifications
// In parallel delete values from classification array when they are used
for (l=1;l<lines.length;l++) {
	entry = split(lines[l], "\t");
	id = entry[0]+"\t"+entry[1];
	cell = arrayIndexOf(sorting, id);
	if (cell == -1) add = " ";
	else {
		add = assignedflags[cell];
		sorting = arrayRemoveItem(sorting, cell);
		assignedflags = arrayRemoveItem(assignedflags, cell);
	}
	if (col == ncol) entry = Array.concat(entry, add);
	else if (cell != -1) entry[col] = add;
	x = arrayCollapse(entry, "\t");
	lines[l] = x;
}

// Add leftover classifications to the end of the file
// In parallel add empty spaces for old calssification columns
for (c=0;c<assignedflags.length;c++) {
	entry = split(sorting[c], "\t");
	i=2;
	while(i<ncol) {
		entry = Array.concat(entry, " ");
		i++;
	}
	if (col == ncol) entry = Array.concat(entry, " ");
	entry[col] = assignedflags[c];
	line = arrayCollapse(entry, "\t");
	lines = Array.concat(lines, line);
}

// save new classifications
if (File.exists(flagfile)) x=File.delete(flagfile);
flagfile = File.open(flagfile);
for (i=0;i<lines.length;i++) {
	print(flagfile, lines[i]);
}
File.close(flagfile);

// Remove safety copy
x=File.delete(dir+File.separator+rndcopy);
if (File.exists(dirspool+File.separator+"log.txt")) {
	entry = getDateYMD();
	folder = File.getName(dir);
	flags = arrayCollapse(clickflag, ", ");
	entry = entry+"\t"+name+"\tfinished classification\t-";
	File.append(entry, dirspool+File.separator+"log.txt");
}
print("Classifications in "+dirspool+File.separator+"classification.csv were updated.");


// Utility functions
function removeDuplicateCharacters(s) {
	y = newArray();
	for (i=0;i<lengthOf(s);i++) {
		q = substring(s, i, i+1);
		if (arrayIndexOf(y,q) == -1) y = Array.concat(y, q);
	}
	y = Array.sort(y);
	o = y[0];
	if (y.length>1) {
		for (i=1;i<y.length;i++) {
			o = o+y[i];
		}
	}
	return o;
}
function pad(n) {
	str = toString(n);
	while (lengthOf(str)<4)
	    str = "0" + str;
	return str;
}
function arrayIndexOf(array, string) {
	index = -1;
	i = 0;
	while (i<array.length) {
		if (startsWith(array[i], string)) {
			index = i;
			i = array.length-1;
		}
		i++;
	}
	return index;
}
function arrayRemoveItem(array, index) {
	if (index >= array.length || index < 0) exit("Index "+index+" out of bounds."); // out of bounds
	else if (index == 0) out = Array.slice(array, 1, array.length); // first element
	else if (index == array.length-1) out = Array.slice(array, 0, array.length-1); // last element
	else {
		start = Array.trim(array, index);
		end = Array.slice(array, index+1, array.length);
		out = Array.concat(start, end);
	}
	return out;
}
function arrayCollapse(a, s) {
	i=0;
	c="";
	while(i<a.length) {
		c=""+c+s+a[i];
		i++;
	}
	c = substring(c, lengthOf(s), lengthOf(c));
	return c;
}
function readSettings(filename) {
	content = File.openAsString(filename);
	lines=split(content,"\n");
	separators = newArray("\t", ",,", ";;"); // Add more separators here if you are desperate.
	separator = 0;
	for (s=0;s<separators.length;s++) {
		l=0;
		separatorValid = 1;
		while (separatorValid == 1 && l<lines.length) {
			args = split(lines[l],separators[s]);
			if (args.length != 2) separatorValid = 0;
			l++;
		}
		if (separatorValid == 1) separator = separators[s];
	}
	if (separator == 0) exit("Settings couldn't be read with either tab, comma or semicolon as field separator.");
	settings = split(lines[0], separator);
	i=1;
	while (i < lines.length) {
		args = split(lines[i], separator);
		settings = Array.concat(settings, args);
		i++;
	}
	return settings;
}
function updateOverlay(rows, columns, tw, assembly, array) {
	Overlay.remove();
	for(r=0;r<rows;r++) {
		for(c=0;c<columns;c++) {
			if ((r*columns)+c+(assembly*rows*columns)<array.length) {
				xoffset = (c+0.03)*tw;
				yoffset = (r+0.97)*tw;
				Overlay.drawString(array[(r*columns)+c+(assembly*rows*columns)], xoffset, yoffset);
			}
		}
	}
	Overlay.show();
	return;
}
function getDateYMD() {
	getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
	date = ""+year+"";
	month = month+1;
	if (month<10) date = date+"0";
	date = date+month;
	if (dayOfMonth<10) date = date+"0";
	date = date+dayOfMonth;
	return date;
}
function getSetting(settings, field, def) {
	id = arrayIndexOf(settings, field);
	if (id == -1) return def;
	id = id+1;
	if (id >= settings.length) return def;
	val = settings[id];
	return val;
}