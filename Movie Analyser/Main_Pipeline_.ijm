// --------------------------------------------------
// MAIN PIPELINE OF MOVIE ANALYSER by JULIA SCHESSNER
// --------------------------------------------------

// OUTLINE:
// --------
// 0. Get settings from file or define defaults
// 1. Get directory and detect raw data files
// 2. Generate GUI and get user input
// 3. Run preprocessing, i.e. initial conversions, drift correction and cell segmentation
// 4. Run data reduction, i.e. cropping to signle cell movies
// 5. Generate entry point for further analysis, i.e. unbiased montages

// Tested working FIJI builds: 
// Required resources: MTrack2_mod plugin, Montage_Maker_.ijm, Feature_Quantifier_.ijm
debugmode = false;

// {{{ 0. Get settings from file or define defaults
// ------------------------------------------------
args = getArgument();
if (lengthOf(args) != 0) { // arguments included in call
	cmd = true; // parameter indicating if pipeline was run from the command line
	dirspool = call("ij.Prefs.get", "MovieAnalyser.Experiment", "\home");
	sets = readSettings(dirspool+args);
	// Read settings to variables
	channelProcessing   = getSetting(sets, "MP.channelProcessing");
	channelProcessing   = split(channelProcessing, ",,");
	rbRadius            = getSetting(sets, "MP.rbRadius");
	bSavePreprocessing  = getSetting(sets, "MP.bSavePreprocessing");
	bSaveMemory         = getSetting(sets, "MP.bSaveMemory");
	bCorrectDrift       = getSetting(sets, "MP.bCorrectDrift");
	driftChannel        = getSetting(sets, "MP.driftChannel");
	bSegmentationMask   = getSetting(sets, "MP.bSegmentationMask");
	segmentationChannel = getSetting(sets, "MP.segmentationChannel");
	segSigma            = getSetting(sets, "MP.segSigma");
	segRadius           = getSetting(sets, "MP.segRadius");
	bskipToCrops        = getSetting(sets, "MP.bskipToCrops");
	bModifySegmentation = getSetting(sets, "MP.bModifySegmentation");
	bCropMovies         = getSetting(sets, "MP.bCropMovies");
	assemblyChoice      = getSetting(sets, "MP.assemblyChoice");
	bMixPoints          = getSetting(sets, "MP.bMixPoints");
	coverage			= getSetting(sets, "MM.coverage");
}
else {
	cmd = false;
	// generate defaults
	rbRadius            = 80;
	bSavePreprocessing  = true;
	bSaveMemory         = true;
	bCorrectDrift       = true;
	driftChannel        = 1;
	bSegmentationMask   = true;
	segmentationChannel = 1;
	segSigma            = 2;
	segRadius           = 25;
	bskipToCrops        = true;
	bModifySegmentation = false;
	bCropMovies         = true;
	assemblyChoice      = "unbiased 10% each";
	bMixPoints          = true;
	coverage			= " ";
}

// }}}

// {{{ 1. Get directory and detect raw data files
// ----------------------------------------------

if (!cmd) dirspool = getDirectory("Select the spooling folder ...");
setBatchMode(true);

// Get list of all raw image files
files = getFileList(dirspool);
i = 0;
while (i<files.length) { // remove non-image files from the list
	if (!endsWith(files[i], ".nd2") && !endsWith(files[i], ".tif") && !endsWith(files[i], ".tiff")) {
		files = arrayRemoveItem(files, i);
	}
	else i++;
}
files = Array.sort(files);

// Detect number of fields of view imaged
points = 0; // counter for points
i=0;p=-1;
while (i<files.length) { // Detect unique points form file-names
	file = split(files[i], "PointSeq._"); // Split by pattern as generated by the Nikon point loop
	p2 = parseInt(file[0]); // First element is the point number
	if (p != p2) { // If the last file wasn't from the same point, count up
		p = p2;
		points++;
	}
	i++;
}

// Exit if number of files can't be devided into an equal number of files per FOV
if (files.length%points != 0) exit(files.length+" files found, which can't be split into "+points+" points.");
// Otherwise calculate number of channels per FOV
channels = files.length/points;

// }}}

// {{{ 2. Generate GUI and get user input
// --------------------------------------

// Options for drop down menus
processingOpts = newArray("none", "reduce to 8-bit", "background subtraction", "load processing from file");
if (!cmd) channelProcessing = newArray("none", "background subtraction", "background subtraction", "background subtraction");
while (channelProcessing.length < channels) {
	channelProcessing = Array.concat(channelProcessing, channelProcessing[channelProcessing.length-1]);
}
channelOpts = Array.getSequence(channels);
for(i=0;i<channelOpts.length;i++) channelOpts[i]=""+(i+1)+"";
assemblyOpts = newArray("none", "unbiased 10% each", "unbiased 50 each", "unbiased 100 each", "top 10% channel 1", "top 50 channel 1", "top 100 channel 1", "top 10% channel 2", "top 50 channel 2", "top 100 channel 2", "top 10% channel 3", "top 50 channel 3", "top 100 channel 3");

// Generate dialog
Dialog.create("Specify image data and processing steps.");
// Specify channel conversions
Dialog.addMessage(points+" points detected with "+channels+" channels each.");
for(i=1;i<=channels;i++) {
	if (File.exists(dirspool+File.separator+"bgsub")) Dialog.addChoice("Channel "+i+" processing:", processingOpts, processingOpts[3]);
	else Dialog.addChoice("Channel "+i+" processing:", processingOpts, channelProcessing[i-1]);
}
// Specifiy further processing
Dialog.addNumber("Rolling ball radius:", rbRadius);
Dialog.addCheckbox("Save preprocessing", bSavePreprocessing);
Dialog.addCheckbox("Save memory (will make it slower)", bSaveMemory);
Dialog.addCheckbox("Correct drift", bCorrectDrift);
Dialog.addChoice("Correct drift based on channel ", channelOpts, driftChannel);
Dialog.addCheckbox("Generate Segmentation mask", bSegmentationMask);
Dialog.addChoice("Segment based on channel ", channelOpts, segmentationChannel);
// advanced setting: Dialog.addNumber("Sigma for gaussian filter on the segmentation channel:", segSigma);
// advanced setting: Dialog.addNumber("Radius for background subtraction on the segmentation channel:", segRadius);
if (File.exists(dirspool+File.separator+"segmentation")) Dialog.addCheckbox("Skip all previous steps and go straight to cropping or assemblies", bskipToCrops);
Dialog.addCheckbox("Allow user modification before cropping", bModifySegmentation);
Dialog.addCheckbox("Crop to single cell movies", bCropMovies);
Dialog.addChoice("Generate assemblies :", assemblyOpts, assemblyChoice);
Dialog.addCheckbox("Mix points during assembly generation", bMixPoints);
Dialog.show();

// Read out input; variable starting with b are boolean to define the pipeline
channelProcessing = newArray(channels);
for(i=0;i<channels;i++) {
	channelProcessing[i] = Dialog.getChoice();
}
rbRadius = Dialog.getNumber();
bSavePreprocessing = Dialog.getCheckbox();
bSaveMemory = Dialog.getCheckbox();
bCorrectDrift = Dialog.getCheckbox();
driftChannel = Dialog.getChoice();
driftChannel = parseInt(driftChannel);
bSegmentationMask = Dialog.getCheckbox();
segmentationChannel = Dialog.getChoice();
segmentationChannel = parseInt(segmentationChannel);
// segSigma = Dialog.getNumber();
// segRadius = Dialog.getNumber();
if (File.exists(dirspool+File.separator+"segmentation")) bskipToCrops = Dialog.getCheckbox();
else bskipToCrops = false;
bModifySegmentation = Dialog.getCheckbox();
bCropMovies = Dialog.getCheckbox();
assemblyChoice = Dialog.getChoice();
bMixPoints = Dialog.getCheckbox();

// write settings for this run
newsets = Array.copy(sets);
charchannelProcessing  = "";
for (i=0;i<channels;i++) charchannelProcessing=charchannelProcessing+","+channelProcessing[i];
charchannelProcessing = substring(charchannelProcessing,1,lengthOf(charchannelProcessing));
newsets = setSetting(newsets, "MP.channelProcessing", charchannelProcessing);
newsets = setSetting(newsets, "MP.rbRadius", rbRadius);
newsets = setSetting(newsets, "MP.bSavePreprocessing", bSavePreprocessing);
newsets = setSetting(newsets, "MP.bSaveMemory", bSaveMemory);
newsets = setSetting(newsets, "MP.bCorrectDrift", bCorrectDrift);
newsets = setSetting(newsets, "MP.driftChannel", driftChannel);
newsets = setSetting(newsets, "MP.bSegmentationMask", bSegmentationMask);
newsets = setSetting(newsets, "MP.segmentationChannel", segmentationChannel);
newsets = setSetting(newsets, "MP.bModifySegmentation", bModifySegmentation);
newsets = setSetting(newsets, "MP.bskipToCrops", bskipToCrops);
newsets = setSetting(newsets, "MP.bCropMovies", bCropMovies);
newsets = setSetting(newsets, "MP.assemblyChoice", assemblyChoice);
newsets = setSetting(newsets, "MP.bMixPoints", bMixPoints);

// write settings file
if (File.exists(dirspool+"parameters_imageprocessing.cfg")) f = File.delete(dirspool+"parameters_imageprocessing.cfg");
w = writeSettings(dirspool+"parameters_imageprocessing.cfg", newsets);

// }}}

// Generate log print for what will be done
print("A total of "+files.length+" files for "+points+" fields of view and "+channels+" channels will be analysed");
// {{{ 3. Run preprocessing, i.e. initial conversions, drift correction and cell segmentation
// ------------------------------------------------------------------------------------------

// Generate variables holding the directory paths
dirbgsub = dirspool+File.separator+"bgsub";
dirdrift = dirspool+File.separator+"drift";
dirseg = dirspool+File.separator+"segmentation";
tStart = getTime();

// Run if the user didn't tick the option to go straight to the crops
if (!bskipToCrops) {
// -----------------

// {{{ 3.1. Make preparations and clarify what is to be done if necessary
// ----------------------------------------------------------------------

// Check if any initial conversions should be in principle done or loaded and generate folder
bPreprocessing = false;
for (i=0;i<channelProcessing.length;i++) {
	if (channelProcessing[i] != "none") bPreprocessing = true;
}
if (bSaveMemory) bPreprocessing = true;
if (bPreprocessing && !File.exists(dirbgsub)) {
	File.makeDirectory(dirbgsub);
}

// Check if driftcorrection should be done and generate folder
if (bCorrectDrift && !File.exists(dirdrift)) {
	File.makeDirectory(dirdrift);
}

// Check if Segmentation masks should be generated and generate folder, ask for overwriting
if (bSegmentationMask && !File.exists(dirseg)) { // should be done and wasn't before
	File.makeDirectory(dirseg);
}
// Define entry points to the analysis for every point, ask user which things to overwrite
pEntryPoints = newArray(points);
bFirstConflict = true;
bAutomatic = false;
bOverwriteAll = false;
bTickAll = false;
for (p=0;p<points;p++) { // for each point
	dropDownChoices = newArray(); // Possible entry points to the analysis for this point
	ask = false;
	// Check initial conversions if not all of them are set to read file
	check = false;
	for (i=0;i<channelProcessing.length;i++) {
		if (channelProcessing[i] != "load processing from file") check = true;
	}
	if (bPreprocessing && check) {
		// Get file list of non-RAM saving version
		bgsubfiles = getFileList(dirbgsub);
		i = 0;
		while (i<bgsubfiles.length) { // remove non-image files from the list
			if (!endsWith(bgsubfiles[i], ".tif")) bgsubfiles = arrayRemoveItem(bgsubfiles, i);
			else i++;
		}
		pdirbgsub = dirbgsub+File.separator+"Point"+pad(p);
		if (File.exists(pdirbgsub)) { // conversions for this point were previously done with RAM saving
			bgfiles = getFileList(pdirbgsub);
			if (lengthOf(bgfiles) != 0) { // folder actually contains data
				dropDownChoices = Array.concat(dropDownChoices, "raw data");
				dropDownChoices = Array.concat(dropDownChoices, "preprocessed data");
				ask = true;
			}
		}
		else if (lengthOf(bgsubfiles) != 0) { // conversions were previously done with RAM saving
			pfileNameStart = "Point"+pad(p);
			if (arrayIndexOf(bgsubfiles, pfileNameStart) != -1) { // file for this point actually included
				dropDownChoices = Array.concat(dropDownChoices, "raw data");
				dropDownChoices = Array.concat(dropDownChoices, "preprocessed data");
				ask = true;
			}
		}
	}
	// Check drift correction
	if (bCorrectDrift) {
		pdirdrift = dirdrift+File.separator+"Point"+pad(p);
		if (File.exists(pdirdrift)) { // drift correction was done
			driftfiles = getFileList(pdirdrift);
			if (lengthOf(driftfiles) != 0) { // folder actually contains data
				if (arrayIndexOf(dropDownChoices, "raw data") == -1) dropDownChoices = Array.concat(dropDownChoices, "raw data");
				if (bPreprocessing && bSavePreprocessing && arrayIndexOf(dropDownChoices, "preprocessed data") == -1) dropDownChoices = Array.concat(dropDownChoices, "preprocessed data");
				dropDownChoices = Array.concat(dropDownChoices, "drift corrected data");
				ask = true;
			}
		}
	}
	// Check Segmentation
	if (bSegmentationMask) {
		segfiles = getFileList(dirseg);
		if (lengthOf(segfiles) != 0) { // segmentation was done
			segfile = "BernsenThreshold_"+pad(p)+".tif";
			if (arrayIndexOf(segfiles, segfile) != -1) { // file for this point actually included
				if (arrayIndexOf(dropDownChoices, "raw data") == -1) dropDownChoices = Array.concat(dropDownChoices, "raw data");
				if (bPreprocessing && bSavePreprocessing && arrayIndexOf(dropDownChoices, "preprocessed data") == -1) dropDownChoices = Array.concat(dropDownChoices, "preprocessed data");
				if (bCorrectDrift && arrayIndexOf(dropDownChoices, "drift corrected data") == -1) dropDownChoices = Array.concat(dropDownChoices, "drift corrected data");
				dropDownChoices = Array.concat(dropDownChoices, "segmented data");
				ask = true;
			}
		}
	}
	// Check Cropping
	if (bCropMovies) {
		dircrops = dirspool+File.separator+"crops";
		pdircrops = dircrops+File.separator+"Point"+pad(p);
		if (File.exists(pdircrops)) { // cropping was done
			if (arrayIndexOf(dropDownChoices, "raw data") == -1) dropDownChoices = Array.concat(dropDownChoices, "raw data");
			if (bPreprocessing && bSavePreprocessing && arrayIndexOf(dropDownChoices, "preprocessed data") == -1) dropDownChoices = Array.concat(dropDownChoices, "preprocessed data");
			if (bCorrectDrift && arrayIndexOf(dropDownChoices, "drift corrected data") == -1) dropDownChoices = Array.concat(dropDownChoices, "drift corrected data");
			if (bSegmentationMask && arrayIndexOf(dropDownChoices, "segmented data") == -1) dropDownChoices = Array.concat(dropDownChoices, "segmented data");
			dropDownChoices = Array.concat(dropDownChoices, "cropped movies");
			ask = true;
		}
	}
	
	// Ask if automatic detection should be done
	if (ask && bFirstConflict) {
		Dialog.create("Files found");
		Dialog.addMessage("Some analysis files for point "+p+" already exist.\nHow do you want to proceed?");
		Dialog.addChoice("", newArray("Automatically continue a crashed run", "Overwrite everything", "Specify individually"), "");
		Dialog.show();
		choice = Dialog.getChoice();
		if (choice == "Automatically continue a crashed run") bAutomatic = true;
		else if (choice == "Overwrite everything") bOverwriteAll = true;
		bFirstConflict = false;
	}
	
	// Specify individually
	if (ask && !bAutomatic && !bOverwriteAll && !bTickAll) {
		Dialog.create("Files found")
		Dialog.addMessage("Some analysis files for point "+p+" already exist.\nFrom which data basis do you want to continue the analysis, overwriting files for the following steps?\nPreprocessed channels, designated to be loaded won't be deleted if you select 'raw data'.");
		Dialog.addChoice("Continue with ", dropDownChoices, 0);
		Dialog.addCheckbox("Use selection for all following points if possible", false);
		Dialog.show();
		pEntryPoints[p] = Dialog.getChoice();
		bTickAll = Dialog.getCheckbox();
		if (bTickAll) choice = pEntryPoints[p];
		print("Point "+p+" will be continued from "+pEntryPoints[p]+".");
	}
	// Detect automatically
	else if (ask && bAutomatic) {
		pEntryPoints[p] = dropDownChoices[dropDownChoices.length-1];
	}
	// Overwrite all
	else if (ask && bOverwriteAll) {
		pEntryPoints[p] = 0;
	}
	// Ticked all
	else if (ask && bTickAll) {
		if (arrayIndexOf(dropDownChoices, choice) != -1) {
			pEntryPoints[p] = choice;
		}
		else {
			pEntryPoints[p] = dropDownChoices[dropDownChoices.length-1];
		}
	}
	
	// Convert to numeric code
	if (lengthOf(pEntryPoints[p]) == 0) pEntryPoints[p] = 0;
	else if (toString(pEntryPoints[p]) == "raw data") pEntryPoints[p] = 0;
	else if (toString(pEntryPoints[p]) == "preprocessed data") pEntryPoints[p] = 1;
	else if (toString(pEntryPoints[p]) == "drift corrected data") pEntryPoints[p] = 2;
	else if (toString(pEntryPoints[p]) == "segmented data") pEntryPoints[p] = 3;
	else if (toString(pEntryPoints[p]) == "cropped movies") pEntryPoints[p] = 4;
	
	// Delete old files
	if (pEntryPoints[p] < 1 && !debugmode) { // delete preprocessing
		pdirbgsub = dirbgsub+File.separator+"Point"+pad(p);
		for (c=0;c<channels;c++) {
			fileId = (p*channels)+c;
			fileTifName = split(files[fileId], "..");
			fileTifName = fileTifName[0]+".tif";
			firstTifName = "t"+pad(1)+"_z"+pad(1)+"_c"+c+1+".tif";
			if (File.exists(dirbgsub+File.separator+fileTifName)) { // remnants of non-RAM saving analysis present
				if (channelProcessing[c] != "load processing from file" || bSaveMemory) { // that are not supposed to be read again
					print("Deleting old preprocessing of point "+p+" channel "+(c+1)+".");
					File.delete(dirbgsub+File.separator+fileTifName);
				}
			}
			if (File.exists(pdirbgsub+File.separator+firstTifName)) { // remnants of RAM saving analysis present
				if (channelProcessing[c] != "load processing from file" || !bSaveMemory) { // that are not supposed to be read again
					bgfiles = getFileList(pdirbgsub);
					print("Deleting old preprocessing of point "+p+" channel "+(c+1)+".");
					i = 0;
					while(i<bgfiles.length) {
						if (!endsWith(bgfiles[i], c+1+".tif")) bgfiles = arrayRemoveItem(bgfiles, i);
						else i++;
					}
					for (i=0;i<bgfiles.length;i++) ok = File.delete(pdirbgsub+File.separator+bgfiles[i]);
					ok = File.delete(pdirbgsub);
				}
			}
		}
	}
	if (pEntryPoints[p] < 2 && !debugmode) { // delete drift data
		pdirdrift = dirdrift+File.separator+"Point"+pad(p);
		driftfiles = getFileList(pdirdrift);
		if (lengthOf(driftfiles) != 0) { // remnants of drift correction present
			for (i=0;i<driftfiles.length;i++) ok = File.delete(pdirdrift+File.separator+driftfiles[i]);
			ok = File.delete(pdirdrift);
		}
	}
	if (pEntryPoints[p] < 3 && !debugmode) { // delete segmentation
		segfile = dirseg+File.separator+"BernsenThreshold_"+pad(p)+".tif";
		if (File.exists(segfile)) ok = File.delete(segfile); // remnants of segmentation present
	}
}

// If necessary automatically detect steps in the entry points
if (bAutomatic) {
	found = false;
	p = 0;
	while (!found && p<points) { // for each point
		if (!found && p == points-1) { // last point reached
			dircrops = dirspool+File.separator+"crops";
			if (!File.exists(dircrops)) {
				pEntryPoints[p]--;
				found = true;
			}
		}
		else if (pEntryPoints[p] > pEntryPoints[p+1] && pEntryPoints[p+1] == pEntryPoints[points-1] && (p != points-2 || pEntryPoints[p+1] == 0)) { // any previous point
			pEntryPoints[p]--;
			found = true;
		}
		if (found && !debugmode) {
			// Delete old files
			if (pEntryPoints[p] < 1) { // delete preprocessing
				pdirbgsub = dirbgsub+File.separator+"Point"+pad(p);
				for (c=0;c<channels;c++) {
					fileId = (p*channels)+c;
					fileTifName = split(files[fileId], "..");
					fileTifName = fileTifName[0]+".tif";
					firstTifName = "t"+pad(1)+"_z"+pad(1)+"_c"+c+1+".tif";
					if (File.exists(dirbgsub+File.separator+fileTifName)) { // remnants of non-RAM saving analysis present
						if (channelProcessing[c] != "load processing from file" || bSaveMemory) { // that are not supposed to be read again
							print("Deleting old preprocessing of point "+p+" channel "+(c+1)+".");
							File.delete(dirbgsub+File.separator+fileTifName);
						}
					}
					if (File.exists(pdirbgsub+File.separator+firstTifName)) { // remnants of RAM saving analysis present
						if (channelProcessing[c] != "load processing from file" || !bSaveMemory) { // that are not supposed to be read again
							bgfiles = getFileList(pdirbgsub);
							print("Deleting old preprocessing of point "+p+" channel "+(c+1)+".");
							i = 0;
							while(i<bgfiles.length) {
								if (!endsWith(bgfiles[i], c+1+".tif")) bgfiles = arrayRemoveItem(bgfiles, i);
								else i++;
							}
							for (i=0;i<bgfiles.length;i++) ok = File.delete(pdirbgsub+File.separator+bgfiles[i]);
							ok = File.delete(pdirbgsub);
						}
					}
				}
			}
			if (pEntryPoints[p] < 2) { // delete drift data
				pdirdrift = dirdrift+File.separator+"Point"+pad(p);
				driftfiles = getFileList(pdirdrift);
				if (lengthOf(driftfiles) != 0) { // remnants of drift correction present
					for (i=0;i<driftfiles.length;i++) ok = File.delete(pdirdrift+File.separator+driftfiles[i]);
					ok = File.delete(pdirdrift);
				}
			}
			if (pEntryPoints[p] < 3) { // delete segmentation
				segfile = dirseg+File.separator+"BernsenThreshold_"+pad(p)+".tif";
				if (File.exists(segfile)) ok = File.delete(segfile); // remnants of segmentation present
			}
		}
		p++; // increment
	}
}

altProcessingOpts = newArray("none", "reduce to 8-bit", "background subtraction");
altChannelProcessing = newArray(channels);

// }}}

if (debugmode) {
	Array.print(pEntryPoints);
	exit("Debugging");
}

// Loop through points to run the preprocessing on them
for (p=0;p<points;p++) {
	
	tThree = getTime();
	
	// Point folder variables:
	pdirbgsub = dirbgsub+File.separator+"Point"+pad(p);	
	pdirdrift = dirdrift+File.separator+"Point"+pad(p);

	// {{{ 3.2. Initial conversions
	// ----------------------------
	
	if (bPreprocessing && pEntryPoints[p] < 1) { // start from raw data
	
	// generate point bgsub folder if bSaveMemory was selected
	if (bSaveMemory && !File.exists(pdirbgsub)) File.makeDirectory(pdirbgsub);
	
	// Get alternative channel processing if necessary
	for (c=0;c<channels;c++) {
		fileId = (p*channels)+c;
		fileTifName = split(files[fileId], "..");
		fileTifName = fileTifName[0]+".tif";
		firstTifName = "t"+pad(1)+"_z"+pad(1)+"_c"+c+1+".tif";
		if (channelProcessing[c] == "load processing from file") {
			if (bSaveMemory && !File.exists(pdirbgsub+File.separator+firstTifName) && altChannelProcessing[c] == 0) { // File not existent --> ask for alternative
				Dialog.create("File not found ...");
				Dialog.addMessage(pdirbgsub+File.separator+firstTifName+" could not be loaded.");
				Dialog.addChoice("Alternative preprocessing:", altProcessingOpts, altProcessingOpts[0]);
				Dialog.show();
				altChannelProcessing[c] = Dialog.getChoice();
			}
			if (!bSaveMemory && !File.exists(dirbgsub+File.separator+fileTifName) && altChannelProcessing[c] == 0) { // File not existent --> ask for alternative
				Dialog.create("File not found ...");
				Dialog.addMessage(dirbgsub+File.separator+fileTifName+" could not be loaded.");
				Dialog.addChoice("Alternative preprocessing:", altProcessingOpts, altProcessingOpts[0]);
				Dialog.show();
				altChannelProcessing[c] = Dialog.getChoice();
			}
		}
	}
	
	// Process channels
	for (c=0;c<channels;c++) {
		
		if (bSaveMemory) { // Memory saving version, where everything gets written to files instantly
			print("Reading point "+p+" channel "+(c+1)+".");
			fileId = (p*channels)+c;
			firstTifName = "t"+pad(1)+"_z"+pad(1)+"_c"+c+1+".tif";
			// Delete or load images
			if (channelProcessing[c] == "load processing from file") { // Load from file
				if (!File.exists(pdirbgsub+File.separator+firstTifName) && altChannelProcessing[c] == 0) { // File not existent --> ask for alternative
					Dialog.create("File not found ...");
					Dialog.addMessage(pdirbgsub+File.separator+firstTifName+" could not be loaded.");
					Dialog.addChoice("Alternative preprocessing:", altProcessingOpts, altProcessingOpts[0]);
					Dialog.show();
					altChannelProcessing[c] = Dialog.getChoice();
				}
			}
			
			// 
			if (channelProcessing[c] == "background subtraction" || (channelProcessing[c] == "load processing from file" && toString(altChannelProcessing[c]) == "background subtraction")) { // Run background subtraction
				run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT use_virtual_stack");
				Stack.getDimensions(width, height, cs, slices, frames);
				subtractBackgroundVHS(pdirbgsub, slices, c+1, rbRadius);
			}
			else if (channelProcessing[c] == "none" || (channelProcessing[c] == "load processing from file" && toString(altChannelProcessing[c]) == "none")) { // Or not
				run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT use_virtual_stack");
				Stack.getDimensions(width, height, cs, slices, frames);
				convertToSingleSliceTifs(pdirbgsub, slices, c+1);
			}
			else if (channelProcessing[c] == "reduce to 8-bit" || (channelProcessing[c] == "reduce to 8-bit" && toString(altChannelProcessing[c]) == "reduce to 8-bit")) {
				run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT use_virtual_stack");
				Stack.getDimensions(width, height, cs, slices, frames);
				convertTo8BitVHS(pdirbgsub, slices, c+1);
			}
			while(nImages>0) close();
			run("Collect Garbage");
		}
		else { // RAM intesive, but much faster version
			print("Reading point "+p+" channel "+(c+1)+".");
			fileId = (p*channels)+c;
			fileTifName = split(files[fileId], "..");
			fileTifName = fileTifName[0]+".tif";
			// Delete or load images
			if (channelProcessing[c] == "load processing from file") { // Load from file
				if (!File.exists(dirbgsub+File.separator+fileTifName) && altChannelProcessing[c] == 0) { // File not existent --> ask for alternative
					Dialog.create("File not found ...");
					Dialog.addMessage(dirbgsub+File.separator+fileTifName+" could not be loaded.");
					Dialog.addChoice("Alternative preprocessing:", altProcessingOpts, altProcessingOpts[0]);
					Dialog.show();
					altChannelProcessing[c] = Dialog.getChoice();
				}
			}
			
			if (channelProcessing[c] == "background subtraction" || (channelProcessing[c] == "load processing from file" && toString(altChannelProcessing[c]) == "background subtraction")) { // Run background subtraction
				run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
				Stack.getDimensions(width, height, cs, slices, frames);
				run("Subtract Background...", "rolling="+rbRadius);
				if (bSavePreprocessing) saveAs("tif", dirbgsub+File.separator+fileTifName);
			}
			else if (channelProcessing[c] == "none" || (channelProcessing[c] == "load processing from file" && toString(altChannelProcessing[c]) == "none")) { // Or not
				run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
				Stack.getDimensions(width, height, cs, slices, frames);
				if (bSavePreprocessing) saveAs("tif", dirbgsub+File.separator+fileTifName);
			}
			else if (channelProcessing[c] == "reduce to 8-bit" || (channelProcessing[c] == "reduce to 8-bit" && toString(altChannelProcessing[c]) == "reduce to 8-bit")) {
				run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
				Stack.getDimensions(width, height, cs, slices, frames);
				run("8-bit");
				if (bSavePreprocessing) saveAs("tif", dirbgsub+File.separator+fileTifName);
			}
			else if (channelProcessing[c] == "load processing from file") {
				run("Bio-Formats Importer", "open=["+dirbgsub+File.separator+fileTifName+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
				Stack.getDimensions(width, height, cs, slices, frames);
			}
		}
	} // end of channels loop
	
	} // End of preprocessing
	else if (!bPreprocessing && pEntryPoints[p] < 2) { // No preprocessing, just read in the data
		// Process channels
		for (c=0;c<channels;c++) {
			print("Reading point "+p+" channel "+(c+1)+".");
			fileId = (p*channels)+c;
			run("Bio-Formats Importer", "open=["+dirspool+files[fileId]+"] color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
			Stack.getDimensions(width, height, cs, slices, frames);
		}
	}
	
	tThreeTwo = getTime();
	print("Initial conversions took "+(tThreeTwo-tThree)+" ms.");
	
	// }}}
	// {{{ 3.3. Drift correction
	// -------------------------
	
	
	if (bCorrectDrift && pEntryPoints[p] < 2) { // run drift correction
		
		// Combine data
		if (bSaveMemory) { // From files as virtual stack
			while(nImages>0) close();
			run("Collect Garbage");
			bgsubfiles = getFileList(pdirbgsub);
			dims = split(bgsubfiles[bgsubfiles.length-1], "tcz_.tif"); // dimensions in frames, zslices, channels
			print("Reading data for drift correction");
			run("Image Sequence...", "open=["+pdirbgsub+"] sort use");
			run("Stack to Hyperstack...", "order=xyczt(default) channels="+dims[2]+" slices="+dims[1]+" frames="+dims[0]+" display=Color");
			slices = dims[1];
		}
		else { // From open images as actual stack
			if (nImages == 0) {
				for (c=0;c<channels;c++) {
					print("Reading point "+p+" channel "+(c+1)+".");
					fileId = (p*channels)+c;
					fileTifName = split(files[fileId], "..");
					fileTifName = fileTifName[0]+".tif";
					open(dirbgsub+File.separator+fileTifName);
				}
			}
			Stack.getDimensions(width, height, cs, slices, frames);
			run("Concatenate...", "all_open title=Point"+pad(p)+"");
			run("Stack to Hyperstack...", "order=xyztc channels="+channels+" slices="+slices+" frames="+frames+" display=Color");
		}
		
		// Generate drift folder if not already done
		if (!File.exists(pdirdrift)) {
			File.makeDirectory(pdirdrift);
		}
		
		// Run drift correction
		print("Calculating drift of Point "+p+".");
		// Temporary solution to 3D drift correction.
		print("Please adjust the following options:\n Channel "+driftChannel+"\nOnly x-y shifts\nUse virtual stack\nSelect the folder at "+pdirdrift+" for that.");
		plugins = getDirectory("plugins");
		c3D = plugins+"Movie Analyser"+File.separator+"Correct_3D_drift.py";
		runMacro(c3D);
		// run("Correct 3D drift", "channel="+driftChannel+" only=0 lowest=1 highest="+slices+" use choose=["+pdirdrift+"]");
		
		// Delete preprocessing if it should not be saved
		if (!bSavePreprocessing) {
			delete = getFileList(pdirbgsub);
			if (lengthOf(delete) != 0) {
				for (i=0;i<delete.length;i++) ok = File.delete(pdirbgsub+File.separator+delete[i]);
			}
		}
		
		tThreeThree = getTime();
		print("Drift correction took "+(tThreeThree-tThreeTwo)+" ms.");
	}
	else tThreeThree = getTime();
	
	
	// }}}
	// {{{ 3.4. Segmentation
	// ---------------------
	if (bSegmentationMask && pEntryPoints[p] < 3) { // run segmentation
		
		// Collect data
		if (bCorrectDrift) { // read in drift corrected data as virtual stack
			while(nImages>0) close();
			run("Collect Garbage");
			driftfiles = getFileList(pdirdrift);
			dims = split(driftfiles[driftfiles.length-1], "tcz_.tif"); // dimensions in frames, zslices, channels 
			print("Reading corrected image sequence");
			run("Image Sequence...", "open=["+pdirdrift+"] sort use");
			run("Stack to Hyperstack...", "order=xyczt(default) channels="+dims[2]+" slices="+dims[1]+" frames="+dims[0]+" display=Color");
			corr = getImageID();
		}
		else if (bSaveMemory && !bCorrectDrift) { // read in preprocessed data as virtual stack
			while(nImages>0) close();
			run("Collect Garbage");
			bgsubfiles = getFileList(pdirbgsub);
			dims = split(bgsubfiles[bgsubfiles.length-1], "tcz_.tif"); // dimensions in frames, zslices, channels
			print("Reading processed image sequence");
			run("Image Sequence...", "open=["+pdirbgsub+"] sort use");
			run("Stack to Hyperstack...", "order=xyczt(default) channels="+dims[2]+" slices="+dims[1]+" frames="+dims[0]+" display=Color");
			slices = dims[1];
		}
		else if (!bSaveMemory && !bCorrectDrift) { // continue with open image (either preprocessed data, or opened raw data)
			run("Concatenate...", "all_open title=Point"+pad(p)+"");
			run("Stack to Hyperstack...", "order=xyztc channels="+channels+" slices="+slices+" frames="+frames+" display=Color");
			corr = getImageID();
		}
		
		// Process to substack and z-Project it
		Stack.getDimensions(width, height, cs, slices, frames)
		print("Segmenting point "+p+".");
		if (bSaveMemory) { // frame wise for ram saving
			run("Make Substack...", "channels="+segmentationChannel+" frames="+1+"");
			substack = getImageID();
			run("Z Project...", "projection=[Max Intensity]");
			rename("zp");
			selectImage(substack);
			close();
			for (frame = 2; frame <= frames; frame++) {
				selectImage(corr);
				run("Make Substack...", "channels="+segmentationChannel+" frames="+frame+"");
				substack = getImageID();
				run("Z Project...", "projection=[Max Intensity]");
				rename("zp1");
				selectImage(substack);
				close();
				run("Concatenate...", "title=zp image1=zp image2=zp1");
				showProgress(frame/frames);
			}
			print("Z-projection of channel "+segmentationChannel+" made.");
			zp = getImageID();
			selectImage(corr);
			close();
		}
		else { // all at once
			run("Make Substack...", "channels="+segmentationChannel+"");
			substack = getImageID();
			selectImage(corr);
			close();
			run("Z Project...", "projection=[Max Intensity] all");
			print("Z-projection of channel "+segmentationChannel+" made.");
			zp = getImageID();
			selectImage(substack);
			close();
		}
		
		// Refine channel and segment
		selectImage(zp);
		run("Gaussian Blur...", "sigma="+segSigma+" stack");
		run("Subtract Background...", "rolling="+segRadius+" stack");
		setSlice(slices);
		resetMinAndMax;
		run("8-bit");
		run("Auto Local Threshold", "method=Bernsen radius=15 parameter_1=0 parameter_2=0 white stack");
		run("Despeckle", "stack");
		run("Invert", "stack");
		run("Fill Holes", "stack");
		save(dirseg+File.separator+"BernsenThreshold_"+pad(p)+".tif");
		close();
		
		tThreeFour = getTime();
		print("Segmentation took "+(tThreeFour-tThreeThree)+" ms.");
	}
	else tThreeFour = getTime();
	
	//}}}
	while(nImages>0) close();
	run("Collect Garbage");
	
} // end of point loop

tThreeTotal = getTime();
print("Preprocessing took "+(tThreeTotal-tThree)+" ms.");
	
} // end of if(!bskipToCrops)

//}}}

// Generate log print of status
tThreeTotal = getTime();
print("Preprocessing of the data is now finished");

// {{{ 4. Run data reduction, i.e. cropping to signle cell movies
// --------------------------------------------------------------

if (bCropMovies) {
	dircrops = dirspool+File.separator+"crops";
	if (!File.exists(dircrops)) { // Check whether folder already exists
		File.makeDirectory(dircrops);
	}
	if (bModifySegmentation) { // Rename the Threshold files, open them and rename the windows
		setBatchMode(false);
		for (p=0;p<points;p++) { // loop through points
			oldTH = "BernsenThreshold_"+pad(p)+".tif";
			newTH = "BernsenThreshold_"+pad(p)+"_automatic.tif";
			File.rename(dirseg+File.separator+oldTH, dirseg+File.separator+newTH);
			open(dirseg+File.separator+newTH);
			rename(oldTH);
			waitForUser("Modify the binary mask as necessary, select the correct window, then click OK");
			save(dirseg+File.separator+oldTH);
			while(nImages>0) close();
		}
	}
	setBatchMode(false);
	for (p=0;p<points;p++) { // loop through points
		pdircrops = dircrops+File.separator+"Point"+pad(p);
		pdirdrift = dirdrift+File.separator+"Point"+pad(p);
		if (!File.exists(pdircrops)) { // Check whether folder already exists
			File.makeDirectory(pdircrops);
			bSkipCrops = false;
		}
		else {
			bSkipCrops = getBoolean("Cells were already cropped previously for point "+p+"\nDo you want to overwrite it?", "No", "Yes");
		}
		if (!bSkipCrops) {
			// Delete previous files
			delete = getFileList(pdircrops);
			if (lengthOf(delete) != 0) {
				print("Deleting files from "+pdircrops);
				for (i=0;i<delete.length;i++) ok = File.delete(pdircrops+File.separator+delete[i]);
			}
			// Open Original data
			driftfiles = getFileList(pdirdrift);
			dims = split(driftfiles[driftfiles.length-1], "tcz_.tif"); // dimensions in frames, zslices, channels 
			print("Generating crops for point "+p+".");
			run("Image Sequence...", "open=["+pdirdrift+"] sort use");
			run("Stack to Hyperstack...", "order=xyczt(default) channels="+dims[2]+" slices="+dims[1]+" frames="+dims[0]+" display=Color");
			run("Set Scale...", "distance=0");
			// Open Segmentation
			open(dirseg+File.separator+"BernsenThreshold_"+pad(p)+".tif");
			run("Set Scale...", "distance=0");
			// Run MTrack2 mod
			call("MTrack2_mod.setProperty","minSize","20");
			call("MTrack2_mod.setProperty","maxSize","1500");
			call("MTrack2_mod.setProperty","minTrackLength","10");
			call("MTrack2_mod.setProperty","maxVelocity","10");
			call("MTrack2_mod.setProperty","saveResultsFile","false");
			call("MTrack2_mod.setProperty","showPaths","false");
			call("MTrack2_mod.setProperty","showPathLengths","false");
			call("MTrack2_mod.setProperty","showLabels","false");
			call("MTrack2_mod.setProperty","showPositions","false");
			call("MTrack2_mod.setProperty","sliceParticles","true");
			call("MTrack2_mod.setProperty","radius","40");
			call("MTrack2_mod.setProperty","sdirectory", pdircrops+File.separator);
			call("MTrack2_mod.setProperty","skipDialogue","true");
			run("MTrack2 mod");
		}
		while(nImages>0) close();
		run("Collect Garbage");
	}
	
	tFour = getTime();
	print("Cropping took "+(tFour-tThreeTotal)+" ms.");
}
else tFour = getTime();

// }}}

// {{{ 5. Generate entry point for further analysis, i.e. unbiased montages
// -------------------

if (assemblyChoice != "none") {
	// Calculate default coverage requirement
	if (coverage == " ") {
		cframe = frames/10*8;
		cframe = floor(cframe);
		pmframes = frames/10;
		pmframes = floor(pmframes);
		coverage = ""+cframe+"+"+pmframes+"-"+pmframes;
	}
	if (bMixPoints) { // Mix cells from all points
		plugins = getDirectory("plugins");
		mm = plugins+"Movie Analyser"+File.separator+"Montage_Maker_.ijm";
		if (assemblyChoice == "unbiased 10% each")      runMacro(mm, "["+dirspool+"] all "+coverage+" frames min-max none none none 3 5 random-10%");
		if (assemblyChoice == "unbiased 50 each")       runMacro(mm, "["+dirspool+"] all "+coverage+" frames min-max none none none 3 5 random-50");
		else if (assemblyChoice == "unbiased 100 each") runMacro(mm, "["+dirspool+"] all "+coverage+" frames min-max none none none 3 5 random-100");
		else if (assemblyChoice == "top 10% channel 1") runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_1 min-max none none none 3 5 top-10%");
		else if (assemblyChoice == "top 50 channel 1")  runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_1 min-max none none none 3 5 top-50");
		else if (assemblyChoice == "top 100 channel 1") runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_1 min-max none none none 3 5 top-100");
		else if (assemblyChoice == "top 10% channel 2") runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_2 min-max none none none 3 5 top-10%");
		else if (assemblyChoice == "top 50 channel 2")  runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_2 min-max none none none 3 5 top-50");
		else if (assemblyChoice == "top 100 channel 2") runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_2 min-max none none none 3 5 top-100");
		else if (assemblyChoice == "top 10% channel 3") runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_3 min-max none none none 3 5 top-10%");
		else if (assemblyChoice == "top 50 channel 3")  runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_3 min-max none none none 3 5 top-50");
		else if (assemblyChoice == "top 100 channel 3") runMacro(mm, "["+dirspool+"] all "+coverage+" max_channel_3 min-max none none none 3 5 top-100");
		while(nImages>0) close();
	}
	else { // 1 call per point
		for (p=0;p<points;p++) { // loop through points
		plugins = getDirectory("plugins");
		mm = plugins+"Movie Analyser"+File.separator+"Montage_Maker_.ijm";
			if (assemblyChoice == "unbiased 10% each")      runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" frames min-max none none none 3 5 random-10%");
			if (assemblyChoice == "unbiased 50 each")       runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" frames min-max none none none 3 5 random-50");
			else if (assemblyChoice == "unbiased 100 each") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" frames min-max none none none 3 5 random-100");
			else if (assemblyChoice == "top 10% channel 1") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_1 min-max none none none 3 5 top-10%");
			else if (assemblyChoice == "top 50 channel 1")  runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_1 min-max none none none 3 5 top-50");
			else if (assemblyChoice == "top 100 channel 1") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_1 min-max none none none 3 5 top-100");
			else if (assemblyChoice == "top 10% channel 2") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_2 min-max none none none 3 5 top-10%");
			else if (assemblyChoice == "top 50 channel 2")  runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_2 min-max none none none 3 5 top-50");
			else if (assemblyChoice == "top 100 channel 2") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_2 min-max none none none 3 5 top-100");
			else if (assemblyChoice == "top 10% channel 3") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_3 min-max none none none 3 5 top-10%");
			else if (assemblyChoice == "top 50 channel 3")  runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_3 min-max none none none 3 5 top-50");
			else if (assemblyChoice == "top 100 channel 3") runMacro(mm, "["+dirspool+"] "+p+" "+coverage+" max_channel_3 min-max none none none 3 5 top-100");
			while(nImages>0) close();
		}
	}
	
	tFive = getTime();
	print("Assembly generation took "+(tFive-tFour)+" ms.");
}
else tFive = getTime();

// }}}

print("Movie analyser pipeline was successfully run.\nYou can now delete all but the crops and assemblies folder if you want to.\nContinue analysing your data by running the Montage Maker, Classifier and Event Recorder as you like.");
print("The whole pipeline took "+(tFive-tStart)+" ms.");

// {{{ Functions:
// --------------
function arrayRemoveItem(array, index) {
	if (index >= array.length || index < 0) exit("Index "+index+" out of bounds."); // out of bounds
	else if (index == 0) out = Array.slice(array, 1, array.length); // first element
	else if (index == array.length-1) out = Array.slice(array, 0, array.length-1); // last element
	else {
		start = Array.trim(array, index);
		end = Array.slice(array, index+1, array.length);
		out = Array.concat(start, end);
	}
	return out;
}
function arrayIndexOf(array, string) {
	index = -1;
	i = 0;
	while (i<array.length) {
		if (startsWith(array[i], string)) {
			index = i;
			i = array.length-1;
		}
		i++;
	}
	return index;
}
function pad(n) {
	str = toString(n);
	while (lengthOf(str)<4)
	    str = "0" + str;
	return str;
}
function subtractBackgroundVHS(dir, zs, c, r) {
  	id = getImageID;
	for (i=1; i<= nSlices; i++) {
		z = i%zs;
		if (z==0) z=zs;
		t=(i-z+zs)/zs;
		selectImage(id);
		setSlice(i);
		run("Duplicate...", "title=temp");
		run("Subtract Background...", "rolling="+r);
		saveAs("tif", dir+File.separator+"t"+pad(t)+"_z"+pad(z)+"_c"+c);
		close();
		showProgress(i/nSlices);
	}
}
function convertToSingleSliceTifs(dir, zs, c) {
	id = getImageID;
	for (i=1; i<= nSlices; i++) {
		z = i%zs;
		if (z==0) z=zs;
		t=(i-z+zs)/zs;
		selectImage(id);
		setSlice(i);
		run("Duplicate...", "title=temp");
		saveAs("tif", dir+File.separator+"t"+pad(t)+"_z"+pad(z)+"_c"+c);
		close();
		showProgress(i/nSlices);
	}
}
function convertTo8BitVHS(dir, zs, c) {
	id = getImageID;
	for (i=1; i<= nSlices; i++) {
		z = i%zs;
		if (z==0) z=zs;
		t=(i-z+zs)/zs;
		selectImage(id);
		setSlice(i);
		run("Duplicate...", "title=temp");
		run("8-bit");
		saveAs("tif", dir+File.separator+"t"+pad(t)+"_z"+pad(z)+"_c"+c);
		close();
		showProgress(i/nSlices);
	}
}
function getSetting(settings, field) {
	id = arrayIndexOf(settings, field);
	if (id == -1) return "error";
	id = id+1;
	if (id >= settings.length) return "error";
	val = settings[id];
	return val;
}
function setSetting(settings, field, value) {
	id = arrayIndexOf(settings, field);
	if (id == -1) return settings;
	id = id+1;
	if (id >= settings.length) return settings;
	settings[id] = value;
	return settings;
}
function readSettings(filename) {
	content = File.openAsString(filename);
	lines=split(content,"\n");
	if (lengthOf(lines) <=1) exit("Empty file.");
	separators = newArray("\t", ",,", ";;"); // Add more separators here if you are desperate.
	separator = 0;
	for (s=0;s<separators.length;s++) {
		l=0;
		separatorValid = 1;
		while (separatorValid == 1 && l<lines.length) {
			args = split(lines[l],separators[s]);
			if (args.length != 2) separatorValid = 0;
			l++;
		}
		if (separatorValid == 1) separator = separators[s];
	}
	if (separator == 0) exit("Settings couldn't be read with either tab, comma or semicolon as field separator.");
	settings = split(lines[0], separator);
	i=1;
	while (i < lines.length) {
		args = split(lines[i], separator);
		settings = Array.concat(settings, args);
		i++;
	}
	return settings;
}
function writeSettings(filename, settings) {
	if (settings.length%2 != 0) exit("Each setting must have exactly one name and value.");
	if (File.exists(filename)) {
		or = getBoolean("The file "+filename+" already exists. Do you want to overwrite it?", "Yes", "No");
		if (!or) return 0;
		else f = File.delete(filename);
	}
	file = File.open(filename);
	lines = settings.length/2;
	for (l=1;l<=lines;l++) {
		line = settings[(l-1)*2]+"\t"+settings[1+(l-1)*2];
		// print(line);
		print(file, line);
	}
	File.close(file);
	return 1;
}
function getDateYMD() {
	getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
	date = ""+year+"";
	month = month+1;
	if (month<10) date = date+"0";
	date = date+month;
	if (dayOfMonth<10) date = date+"0";
	date = date+dayOfMonth;
	return date;
}
// }}}
